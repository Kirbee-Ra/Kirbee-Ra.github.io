//###########################################################################
//
// 파일:   ADC_Test.c
//
// 제목:  ADC 100 V 센싱 테스트
//
// 설명:
// 이 코드는 TMS320F28379의 ADC 모듈을 사용합니다.
// 외부 전원 100 VDC를 전압 센서에 연결하여 100 VDC를 센싱할 수 있는지 확인합니다.
//
//###########################################################################

#include "F28x_Project.h"

interrupt void adc_isr(void);
interrupt void cputimer0_isr(void);

// ===== 입력 전압 =====
volatile Uint16 adcRaw = 0;    // ADCRESULT0 raw code (0~4095)
volatile float  V_BUS  = 100; // 입력 DC 전압

// ===== DSP 회로 =====
#define SYSCLK_HZ     200000000UL

#define ADC_BITS      12
#define ADC_FS        (1U << ADC_BITS)      // 4096
#define VREF_V        3.3f                  // ADC 기준전압(보드 설정에 맞게)

#define GAIN_NUM      4417
#define GAIN_DEN      25
#define GAIN  ((float)GAIN_NUM/(float)GAIN_DEN)     // V_BUS = GAIN * V_ADC

// 샘플링 주파수
#define FS_SAMPLE_HZ  1000U

static void InitAdcA(void)
{
    EALLOW;
    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;
    AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;

    // PRESCALE 값 의미는 TRM 기준으로 확인 권장
    AdcaRegs.ADCCTL2.bit.PRESCALE = 0;

    AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);

    // EOC0 -> ADCINT1
    AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 0;
    AdcaRegs.ADCINTSEL1N2.bit.INT1E   = 1;

    // 필터/데시메이션 없는 경우, CONT=0 권장(오버런 관리 쉬움)
    AdcaRegs.ADCINTSEL1N2.bit.INT1CONT = 0;

    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
    EDIS;

    DELAY_US(1000);
}

static void InitAdcSoc0_Timer0(void)
{
    EALLOW;
    AdcaRegs.ADCSOC0CTL.bit.CHSEL   = 0;    // ADCINA0
    AdcaRegs.ADCSOC0CTL.bit.ACQPS   = 14;   // 입력 임피던스 높으면 더 키우기
    AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 1;    // CPU Timer0 트리거
    EDIS;
}

static void InitCpuTimer0_Fs(Uint32 fs_hz)
{
    Uint32 prd = (SYSCLK_HZ / fs_hz);

    EALLOW;
    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;

    CpuTimer0Regs.TCR.bit.TSS = 1;
    CpuTimer0Regs.PRD.all     = prd;
    CpuTimer0Regs.TPR.all     = 0;
    CpuTimer0Regs.TPRH.all    = 0;
    CpuTimer0Regs.TCR.bit.TRB = 1;

    CpuTimer0Regs.TCR.bit.TIE = 1;     // Timer ISR 필요없으면 0으로 두셔도 됨(트리거는 발생)
    CpuTimer0Regs.TCR.bit.TSS = 0;
    EDIS;
}

void main(void)
{
    InitSysCtrl();
    InitGpio();
    Device_cal();

    DINT;
    InitPieCtrl();
    IER = 0;
    IFR = 0;
    InitPieVectTable();

    EALLOW;
    PieVectTable.ADCA1_INT  = &adc_isr;
    PieVectTable.TIMER0_INT = &cputimer0_isr;

    PieCtrlRegs.PIEIER1.bit.INTx1 = 1; // ADCA1_INT
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1; // TIMER0_INT
    IER |= M_INT1;
    EDIS;

    InitAdcA();
    InitAdcSoc0_Timer0();
    InitCpuTimer0_Fs(FS_SAMPLE_HZ);

    EINT;
    ERTM;

    for(;;)
    {
        // V_BUS를 그대로 사용(보호/표시/로깅 등)
        // 필요하면 임계값 비교:
        // if (V_BUS > 400.0f) { ... }
    }
}

interrupt void adc_isr(void)
{
    adcRaw = AdcaResultRegs.ADCRESULT0;

    // ADC raw -> ADC 핀 전압
    {
        float V_ADC = ((float)adcRaw) * (VREF_V / (float)(ADC_FS - 1U));
        // 분압 복원 -> 실제 DC 전압 추정
        V_BUS = V_ADC * GAIN;
    }

    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

interrupt void cputimer0_isr(void)
{
    CpuTimer0Regs.TCR.bit.TIF = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
