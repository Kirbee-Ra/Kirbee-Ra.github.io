//###########################################################################
//
// 파일:   ADC_Test.c
//
// 제목:  ADC 100 V 센싱 테스트 (ADCINC2, V_ADC 전역변수)
//
//###########################################################################

#include "F28x_Project.h"

interrupt void adc_isr(void);
interrupt void cputimer0_isr(void);

// ===== ADC 결과/전압 =====
volatile Uint16 adcRaw = 0;        // ADCRESULT0 raw code (0~4095)
volatile float  V_ADC  = 0.0f;     // (추가) ADC 핀 전압 (전역변수: CCS Watch 가능)
volatile float  V_BUS  = 0.0f;     // 분압 복원된 실제 DC 전압 추정치

// ===== DSP 회로/스케일 =====
#define SYSCLK_HZ     200000000UL

#define ADC_BITS      12
#define ADC_FS        (1U << ADC_BITS)      // 4096
#define VREF_V        3.3f                  // ADC 기준전압(보드 설정에 맞게)

#define GAIN_NUM      4417
#define GAIN_DEN      25
#define GAIN          ((float)GAIN_NUM/(float)GAIN_DEN)  // V_BUS = GAIN * V_ADC

// 샘플링 주파수
#define FS_SAMPLE_HZ  1000U

static void InitAdcC(void)
{
    EALLOW;
    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;
    AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;

    AdccRegs.ADCCTL2.bit.PRESCALE = 0;

    AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);

    // EOC0 -> ADCINT1
    AdccRegs.ADCINTSEL1N2.bit.INT1SEL = 0;
    AdccRegs.ADCINTSEL1N2.bit.INT1E   = 1;

    // CONT=0 권장(오버런 관리 쉬움)
    AdccRegs.ADCINTSEL1N2.bit.INT1CONT = 0;

    AdccRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
    EDIS;

    DELAY_US(1000);
}

static void InitAdcSoc0_Timer0(void)
{
    EALLOW;
    AdccRegs.ADCSOC0CTL.bit.CHSEL   = 2;    // ADCINC2
    AdccRegs.ADCSOC0CTL.bit.ACQPS   = 14;   // 입력 임피던스 높으면 더 키우기
    AdccRegs.ADCSOC0CTL.bit.TRIGSEL = 1;    // CPU Timer0 트리거
    EDIS;
}

static void InitCpuTimer0_Fs(Uint32 fs_hz)
{
    Uint32 prd = (SYSCLK_HZ / fs_hz);

    EALLOW;
    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;

    CpuTimer0Regs.TCR.bit.TSS = 1;
    CpuTimer0Regs.PRD.all     = prd;
    CpuTimer0Regs.TPR.all     = 0;
    CpuTimer0Regs.TPRH.all    = 0;
    CpuTimer0Regs.TCR.bit.TRB = 1;

    // Timer ISR 없어도 SOC 트리거는 발생하지만, 디버깅용으로 켜둠
    CpuTimer0Regs.TCR.bit.TIE = 1;
    CpuTimer0Regs.TCR.bit.TSS = 0;
    EDIS;
}

void main(void)
{
    InitSysCtrl();
    InitGpio();
    Device_cal();

    DINT;
    InitPieCtrl();
    IER = 0;
    IFR = 0;
    InitPieVectTable();

    EALLOW;
    PieVectTable.ADCC1_INT  = &adc_isr;
    PieVectTable.TIMER0_INT = &cputimer0_isr;

    PieCtrlRegs.PIEIER1.bit.INTx3 = 1; // ADCC1_INT
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1; // TIMER0_INT
    IER |= M_INT1;
    EDIS;

    InitAdcC();
    InitAdcSoc0_Timer0();
    InitCpuTimer0_Fs(FS_SAMPLE_HZ);

    EINT;
    ERTM;

    for(;;)
    {
        // CCS Watch에서 V_ADC, V_BUS, adcRaw 확인 가능
        // 필요하면 보호 로직 추가:
        // if (V_BUS > 400.0f) { ... }
    }
}

interrupt void adc_isr(void)
{
    adcRaw = AdccResultRegs.ADCRESULT0;

    // 전역변수로 계산 결과 저장 (CCS Watch 가능)
    V_ADC = ((float)adcRaw) * (VREF_V / (float)(ADC_FS - 1U));
    V_BUS = V_ADC * GAIN;

    AdccRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

interrupt void cputimer0_isr(void)
{
    CpuTimer0Regs.TCR.bit.TIF = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
