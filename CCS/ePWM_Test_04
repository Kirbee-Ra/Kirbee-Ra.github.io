//###########################################################################
//
// 파일:   main.c
//
// 제목:  PWM1-12 테스트
//
// 설명:
// 이 코드는 TMS320F28379의 ePWM1-12 모듈을 사용합니다.
// 모든 파형은 A/B 상보 동작 w/ 데드 타임
// ePWM1: 100 kHz, 마스터 파형
// ePWM2: 50 kHz, 듀티 변동 0.1 <-> 0.5
// ePWM3: ePWM1에 대해 60 deg 위상 천이
// ePWM4: ePWM1에 대해 90 deg 위상 천이
// ePWM5: 주파수 변동 50 kHz <-> 100 kHz
// ePWM6: 데드 타임 변동 1% <-> 5%
// ePWM7: 100 kHz, 듀티 변동 0.1 <-> 0.5
// ePWM8: ePWM9가 위상 변동 30 deg <-> 120 deg
// ePWM9: 스위칭하면 위상 천이 45 deg
// 외부 연결: ePWM1-12A/B (GPIO0-23)
//
//###########################################################################

#include "F28x_Project.h" // 디바이스 헤더 파일 및 예제 포함 파일. DSP28x_Project.h을 F28x_Project.h로 변경

// 시스템 및 PWM 설정 상수
#define SYSCLKOUT       200000000UL // 시스템 클럭 (Hz): 200 MHz
#define PWM_FREQ        100000UL     // 목표 PWM 주파수 (Hz): 100 kHz
#define DUTY_CYCLE      50U         // 초기 듀티 사이클 (%): 50% // 듀티 사이클 50 %
#define DEAD_TIME       5e-7        // 데드타임 (초): 0.5 µs
#define EPWMCLK_HZ   (SYSCLKOUT/2UL)         // 지금 측정 결과로 보면 100 MHz
#define TBCLK_HZ     (EPWMCLK_HZ)            // HSPCLKDIV=1, CLKDIV=1 가정

// ePWM2만 주파수가 다르므로 따로 설정
#define PWM2_FREQ       50000UL

// ePWM5는 주파수 변동이므로 따로 설정
#define EPWM5_DUTY_PCT  50U
#define PWM5_FREQ_LOW   50000UL
#define PWM5_FREQ_HIGH  100000UL

// 계산된 레지스터 값 (unsigned 캐스팅으로 경고 제거, 1UL * 1UL로 CLKDIV/HSPCLKDIV 명시)
#define TBPRD_VALUE     ((Uint16)((Uint32)TBCLK_HZ / (PWM_FREQ * 1UL * 1UL)) - 1UL) // up mode, 999 (100 kHz, CLKDIV=1, HSPCLKDIV=1).
#define CMPA_VALUE      ((Uint16)((((Uint32)(TBPRD_VALUE) + 1UL) * (Uint32)(DUTY_CYCLE)) / 100UL)) // 초기 CMPA: 500.
#define DEAD_TIME_TICKS 50U  // 100으로 변경. 0.5us -> 50 ticks (TBCLK=100 MHz)
#define PHASE_TICKS_60  167U // PHASE_TICKS = (TBPRD + 1)*60/360
#define PHASE_TICKS_90  250U // PHASE_TICKS = (TBPRD + 1)*90/360
#define TBPHS_DELAY_60  ((Uint16)((TBPRD_VALUE + 1U) - PHASE_TICKS_60))  // 833
#define TBPHS_DELAY_90  ((Uint16)((TBPRD_VALUE + 1U) - PHASE_TICKS_90))  // 750

// ePWM2만 주파수가 다르므로 따로 설정
#define TBPRD2_VALUE     ((Uint16)((Uint32)TBCLK_HZ / (PWM2_FREQ * 1UL * 1UL)) - 1UL)
#define CMPA2_VALUE      ((Uint16)((((Uint32)(TBPRD2_VALUE) + 1UL) * (Uint32)(DUTY_CYCLE)) / 100UL))

// ePWM5는 주파수 변동이므로 따로 설정
#define TBPRD5_LOW   ((Uint16)(((Uint32)TBCLK_HZ / (Uint32)PWM5_FREQ_LOW ) - 1UL))   // 1999
#define TBPRD5_HIGH  ((Uint16)(((Uint32)TBCLK_HZ / (Uint32)PWM5_FREQ_HIGH) - 1UL))   //  999

// 듀티 변동
#define DUTY_LOW_PCT    10U   // 0.1
#define DUTY_HIGH_PCT   50U   // 0.5

// ePWM6은 데드 타임 변동이므로 따로 설정
#define EPWM6_DEAD_PCT_LOW   1U
#define EPWM6_DEAD_PCT_HIGH  5U

// ePWM8은 위상 변동이므로 따로 설정
#define PHASE_TICKS_30   ((Uint16)((((Uint32)TBPRD_VALUE + 1UL) * 30UL  + 180UL) / 360UL))  // rounding
#define PHASE_TICKS_120  ((Uint16)((((Uint32)TBPRD_VALUE + 1UL) * 120UL + 180UL) / 360UL))  // rounding
#define TBPHS_DELAY_30   ((Uint16)((TBPRD_VALUE + 1U) - PHASE_TICKS_30))
#define TBPHS_DELAY_120  ((Uint16)((TBPRD_VALUE + 1U) - PHASE_TICKS_120))

// ePWM9는 외부 신호에 따른 위상 변동이므로 따로 설정
#define SW_GPIO              62  // GPIO62: SW1
#define EPWM9_PHASE_TICKS    ((Uint16)((((Uint32)TBPRD_VALUE + 1UL) * 450UL + 180UL) / 360UL))  // 45도
#define EPWM9_PHASE_DELAY    ((Uint16)((TBPRD_VALUE + 1U) - EPWM9_PHASE_TICKS))                 // 지연

// ISR 프로토타입(선언)
__interrupt void cpuTimer0ISR(void);

// ePWM9 ISR
__interrupt void EPWM9SW1Int(void);

// 토글용 상태 변수: ePWM2, 7 듀티 0.1 <-> 0.5
volatile Uint16 epwmDutyToggle = 0U;

// 토글용 상태 변수: ePWM5 주파수 변동
volatile Uint16 epwm5FreqToggle = 0U;   // 0:LOW(50k), 1:HIGH(100k)

// 토글용 상태 변수: ePWM6 데드 타임 변동
volatile Uint16 epwm6DeadToggle = 0U;

// 토글용 상태 변수: ePWM8용 위상 변동
volatile Uint16 epwm8PhaseToggle = 0U;  // 0:30deg, 1:120deg

// 상태 변수: ePWM9용 위상 변동
volatile Uint16 epwm9PhaseToggle = 0U;  // 0:30deg, 1:45deg

// ePWM9 외부 신호 함수
void EPWM9SW1(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: SW1을 GPIO62에 연결한 상태
    GpioCtrlRegs.GPBGMUX2.bit.GPIO62 = 0; // 0으로 만들어서 오직 input으로 설정
    GpioCtrlRegs.GPBMUX2.bit.GPIO62 = 0; // 0으로 만들어서 오직 input으로 설정
    GpioCtrlRegs.GPBDIR.bit.GPIO62  = 0;    // 외부 신호를 받기 위해 input으로 설정

    // 2) GPIO62를 XINT1 입력으로 라우팅
    InputXbarRegs.INPUT1SELECT = SW_GPIO;

    // 3) XINT1 설정: 한쪽 에지만(권장: falling)
    XintRegs.XINT1CR.bit.POLARITY = 0;    // 0: falling edge
    XintRegs.XINT1CR.bit.ENABLE   = 1;

    // 4) PIE 벡터 연결
    PieVectTable.XINT1_INT = &EPWM9SW1Int;
    EDIS;

    // 5) PIE/CPU enable (XINT1 = Group1 INT4)
    PieCtrlRegs.PIEIER1.bit.INTx4 = 1;
    IER |= M_INT1;
}

// ePWM1 함수 ######################################################################################################################################################
// DB, 주파수 변동, 상보 동작, 듀티 변동
void InitEPwm1(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM1A와 ePWM1B를 GPIO0, GPIO1에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // GPIO0을 ePWM1A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // GPIO1을 ePWM1B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm1Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm1Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm1Regs.TBCTR = 0; // 카운터 초기화
    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // 위상 로드 비활성화. 마스터 파형이므로 위상(= 0) 안 씀.
    // 여기부터
    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm1Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm1Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm1Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm1Regs.DBCTL.bit.IN_MODE = DBA_ALL; // // DB 입력은 A만 사용.
    EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm1Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm1Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM2 함수 ######################################################################################################################################################
// 주파수 50 kHz, 듀티 변동 0.1 <-> 0.5
void InitEPwm2(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM2A와 ePWM2B를 GPIO2, GPIO3에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // GPIO2을 ePWM2A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // GPIO3을 ePWM2B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm2Regs.TBPRD = TBPRD2_VALUE; // 주기 설정 (50 kHz를 위한 499)
    EPwm2Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm2Regs.TBCTR = 0; // 카운터 초기화
    EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm2Regs.TBCTL.bit.PHSEN = TB_DISABLE; // 위상 로드 비활성화.
    // 여기부터
    EPwm2Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm2Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // 독립된 시간 체계 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm2Regs.CMPA.bit.CMPA = CMPA2_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm2Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm2Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm2Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm2Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm2Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM3 함수 ######################################################################################################################################################
// 60도 위상 지연
void InitEPwm3(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM3A와 ePWM3B를 GPIO4, GPIO5에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 1; // GPIO4을 ePWM3A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 1; // GPIO5을 ePWM3B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm3Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm3Regs.TBPHS.bit.TBPHS = TBPHS_DELAY_60; // 위상 오프셋: 60. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm3Regs.TBCTR = 0; // 카운터 초기화
    EPwm3Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm3Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm3Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm3Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm3Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm3Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm3Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm3Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm3Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm3Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm3Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm3Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm3Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm3Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm3Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm3Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm3Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm3Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM4 함수 ######################################################################################################################################################
// 90도 위상 지연
void InitEPwm4(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM4A와 ePWM4B를 GPIO6, GPIO7에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // GPIO6을 ePWM4A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // GPIO77을 ePWM4B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm4Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm4Regs.TBPHS.bit.TBPHS = TBPHS_DELAY_90; // 위상 오프셋: 90. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm4Regs.TBCTR = 0; // 카운터 초기화
    EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm4Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm4Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm4Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm4Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm4Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm4Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm4Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm4Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM5 함수 ######################################################################################################################################################
// 주파수 변동 50 kHz <-> 100 kHz
void InitEPwm5(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM5A와 ePWM5B를 GPIO8, GPIO9에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 1; // GPIO8을 ePWM5A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 1; // GPIO9을 ePWM5B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm5Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm5Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm5Regs.TBCTR = 0; // 카운터 초기화
    EPwm5Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm5Regs.TBCTL.bit.PHSEN = TB_DISABLE; // 위상 로드 비활성화.
    // 여기부터
    EPwm5Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm5Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm5Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm5Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // 독립된 시간 체계 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm5Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm5Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm5Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm5Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm5Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm5Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm5Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm5Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm5Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm5Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm5Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm5Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm5Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM6 함수 ######################################################################################################################################################
// 데드 타임 변동 1% <-> 5%
void InitEPwm6(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM6A와 ePWM6B를 GPIO10, GPIO11에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO10 = 1; // GPIO10을 ePWM6A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO11 = 1; // GPIO11을 ePWM6B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm6Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm6Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm6Regs.TBCTR = 0; // 카운터 초기화
    EPwm6Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm6Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm6Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm6Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm6Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm6Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm6Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm6Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm6Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm6Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm6Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm6Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm6Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm6Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm6Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm6Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm6Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm6Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm6Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM7 함수 ######################################################################################################################################################
// 듀티 변동 0.1 <-> 0.5
void InitEPwm7(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM7A와 ePWM7B를 GPIO12, GPIO13에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 1; // GPIO12을 ePWM7A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO13 = 1; // GPIO13을 ePWM7B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm7Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm7Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm7Regs.TBCTR = 0; // 카운터 초기화
    EPwm7Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm7Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm7Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm7Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm7Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm7Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm7Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm7Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm7Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm7Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm7Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm7Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm7Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm7Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm7Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm7Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm7Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm7Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm7Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM8 함수 ######################################################################################################################################################
// 위상 변동 30도 <-> 90도
void InitEPwm8(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM8A와 ePWM8B를 GPIO14, GPIO15에 매핑
    GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 1; // GPIO14을 ePWM8A로 설정
    GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 1; // GPIO15을 ePWM8B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm8Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm8Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm8Regs.TBCTR = 0; // 카운터 초기화
    EPwm8Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm8Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화. 슬레이브 파형이므로 위상 씀.
    // 여기부터
    EPwm8Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm8Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm8Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm8Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm8Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm8Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm8Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm8Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm8Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm8Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm8Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm8Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm8Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm8Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm8Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm8Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm8Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM9 함수 ######################################################################################################################################################
// 스위칭하면 위상 변동 0 <-> 45도
void InitEPwm9(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM9A와 ePWM9B를 GPIO16, GPIO17에 매핑
    GpioCtrlRegs.GPAGMUX2.bit.GPIO16 = 1; // GPIO16 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 1; // GPIO16을 ePWM9A로 설정
    GpioCtrlRegs.GPAGMUX2.bit.GPIO17 = 1; // GPIO17 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 1; // GPIO17을 ePWM9B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm9Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm9Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm9Regs.TBCTR = 0; // 카운터 초기화
    EPwm9Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm9Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm9Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm9Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm9Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm9Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm9Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm9Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm9Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm9Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm9Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm9Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm9Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm9Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm9Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm9Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm9Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm9Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm9Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM10 함수 ######################################################################################################################################################
void InitEPwm10(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM10A와 ePWM10B를 GPIO18, GPIO19에 매핑
    GpioCtrlRegs.GPAGMUX2.bit.GPIO18 = 1; // GPIO18 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 1; // GPIO18을 ePWM10A로 설정
    GpioCtrlRegs.GPAGMUX2.bit.GPIO19 = 1; // GPIO19 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO19 = 1; // GPIO19을 ePWM10B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm10Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm10Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm10Regs.TBCTR = 0; // 카운터 초기화
    EPwm10Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm10Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm10Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm10Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm10Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm10Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm10Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm10Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm10Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm10Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm10Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm10Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm10Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm10Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm10Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm10Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm10Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm10Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm10Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM11 함수 ######################################################################################################################################################
void InitEPwm11(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM11A와 ePWM11B를 GPIO20, GPIO21에 매핑
    GpioCtrlRegs.GPAGMUX2.bit.GPIO20 = 1; // GPIO20 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO20 = 1; // GPIO20을 ePWM11A로 설정
    GpioCtrlRegs.GPAGMUX2.bit.GPIO21 = 1; // GPIO21 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO21 = 1; // GPIO21을 ePWM11B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm11Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm11Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm11Regs.TBCTR = 0; // 카운터 초기화
    EPwm11Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm11Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm11Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm11Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm11Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm11Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm11Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm11Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm11Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm11Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm11Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm11Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm11Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm11Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm11Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm11Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm11Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm11Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm11Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// ePWM12 함수 ######################################################################################################################################################
void InitEPwm12(void) {
    EALLOW; // 보호된 레지스터 접근 허용

    // GPIO 설정: ePWM12A와 ePWM12B를 GPIO22, GPIO23에 매핑
    GpioCtrlRegs.GPAGMUX2.bit.GPIO22 = 1; // GPIO22 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO22 = 1; // GPIO22을 ePWM12A로 설정
    GpioCtrlRegs.GPAGMUX2.bit.GPIO23 = 1; // GPIO23 GMUX 설정
    GpioCtrlRegs.GPAMUX2.bit.GPIO23 = 1; // GPIO23을 ePWM12B로 설정

    // 타임 베이스 클럭 동기화 비활성화 (TI 예제 관행)
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0; // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;

    // 타임 베이스 (TB) 설정
    EPwm12Regs.TBPRD = TBPRD_VALUE; // 주기 설정 (100 kHz를 위한 999)
    EPwm12Regs.TBPHS.bit.TBPHS = 0; // 위상 오프셋: 0. F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm12Regs.TBCTR = 0; // 카운터 초기화
    EPwm12Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 업 카운트 모드 (UPDOWN -> UP)
    EPwm12Regs.TBCTL.bit.PHSEN = TB_ENABLE; // 위상 로드 활성화.
    // 여기부터
    EPwm12Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // 고속 클럭 분주: /1
    EPwm12Regs.TBCTL.bit.CLKDIV = TB_DIV1; // 클럭 분주: /1
    EPwm12Regs.TBCTL.bit.PRDLD = TB_SHADOW; // 주기 쉐도우 모드
    EPwm12Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // TBCTR=0에서 동기화 출력 // 뭔지 모름
    // 여기까지는 더 알아볼 것

    // 카운터 비교 (CC) 설정
    EPwm12Regs.CMPA.bit.CMPA = CMPA_VALUE; // 초기 CMPA: 50% 듀티. // F2837x에는 half 대신 bit를 사용하므로 변경
    EPwm12Regs.CMPB.bit.CMPB = 0; // CMPB 초기화 (사용하지 않음, 0으로 설정). // .bit.CMPB를 추가함
    EPwm12Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; // CMPA 쉐도우 모드
    EPwm12Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; // CMPB 쉐도우 모드
    EPwm12Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // CMPA: TBCTR=0일 때 로드
    EPwm12Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // CMPB: TBCTR=0일 때 로드

    // 액션 한정자 (AQ) 설정: 상보 PWM을 위한 구성
    EPwm12Regs.AQCTLA.bit.ZRO = AQ_SET; // Up mode에서는 ZRO에서 set. CAU를 ZRO로 변경.
    EPwm12Regs.AQCTLA.bit.CAU = AQ_CLEAR; // Up mode에서는 CAU에서 clear. CAD를 CAU로 변경.
    // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR; // A만 만들고 B는 데드 타임 + 상보로 동작
    // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET; // A만 만들고 B는 데드 타임 + 상보로 동작

    // 데드밴드 (DB) 설정: 상보 출력용
    EPwm12Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 전체 데드밴드 활성화
    EPwm12Regs.DBCTL.bit.IN_MODE = DBA_ALL; // DB 입력은 A만 사용.
    EPwm12Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // 액티브 하이 상보 (ePWM1A 하이, ePWM1B 인버트)
    EPwm12Regs.DBRED.bit.DBRED = DEAD_TIME_TICKS; // 상승 에지 지연: 0.5 µs (50 틱)
    EPwm12Regs.DBFED.bit.DBFED = DEAD_TIME_TICKS; // 하강 에지 지연: 0.5 µs (50 틱)

    EALLOW;
    // CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 동기화 활성화 // F2837x에는 SysCtrlRegs 대신 CpuSysRegs가 존재하므로 변경
    EDIS;
}

// 듀티, 주파수, 데드 타임 변동 인터럽트
__interrupt void cpuTimer0ISR(void)
{
    Uint16 dutyPct;
    Uint16 tbprd5;

    // ---- 듀티 토글 (ePWM2, ePWM7) ----
    epwmDutyToggle ^= 1U;
    dutyPct = (epwmDutyToggle) ? DUTY_HIGH_PCT : DUTY_LOW_PCT;

    EPwm2Regs.CMPA.bit.CMPA =
        (Uint16)((((Uint32)TBPRD2_VALUE + 1UL) * (Uint32)dutyPct) / 100UL);

    EPwm7Regs.CMPA.bit.CMPA =
        (Uint16)((((Uint32)TBPRD_VALUE + 1UL) * (Uint32)dutyPct) / 100UL);

    // ---- 주파수 토글 (ePWM5: 50k <-> 100k) ----
    epwm5FreqToggle ^= 1U;
    tbprd5 = (epwm5FreqToggle) ? TBPRD5_HIGH : TBPRD5_LOW;

    EPwm5Regs.TBPRD = tbprd5;
    EPwm5Regs.CMPA.bit.CMPA =
        (Uint16)((((Uint32)tbprd5 + 1UL) * (Uint32)EPWM5_DUTY_PCT) / 100UL);

    // ---- 데드타임 토글 (ePWM6: 1% <-> 5%) ----
    {
        Uint16 deadPct;
        Uint16 tbprd6;
        Uint16 deadTicks;

        epwm6DeadToggle ^= 1U;
        deadPct = (epwm6DeadToggle) ? EPWM6_DEAD_PCT_HIGH : EPWM6_DEAD_PCT_LOW;

        // ePWM6가 100kHz 고정이면 TBPRD_VALUE 사용해도 되지만,
        // "현재 ePWM6의 주기" 기준으로 계산하려면 레지스터를 읽는 게 더 안전합니다.
        tbprd6 = EPwm6Regs.TBPRD;

        deadTicks = (Uint16)((((Uint32)tbprd6 + 1UL) * (Uint32)deadPct) / 100UL);

        EPwm6Regs.DBRED.bit.DBRED = deadTicks;
        EPwm6Regs.DBFED.bit.DBFED = deadTicks;
    }

    // ---- 위상 토글 (ePWM8: 30deg <-> 120deg) ----
    {
        Uint16 tbphs8;

        epwm8PhaseToggle ^= 1U;
        tbphs8 = (epwm8PhaseToggle) ? TBPHS_DELAY_120 : TBPHS_DELAY_30;

        EPwm8Regs.TBPHS.bit.TBPHS = tbphs8;

        // 선택: 바로 다음 PWM 주기에서 확실히 반영시키고 싶으면, 마스터에서 SWFSYNC 한번 쏴도 됩니다.
        // EPwm1Regs.TBCTL.bit.SWFSYNC = 1;
    }

    // ---- Timer0 플래그/ACK ----
    CpuTimer0Regs.TCR.bit.TIF = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

// 스위치 인터럽트 --> SW1이 키고 꺼짐에 따라 불러오게 짜기
__interrupt void EPWM9SW1Int(void)
{
    Uint16 tbphs9;

    // SW on이면 위상 지연
    epwm9PhaseToggle ^= 1U;
    tbphs9 = (epwm9PhaseToggle) ? EPWM9_PHASE_DELAY : 0U;

    // ePWM9 함수에 위상 반영
    EPwm9Regs.TBPHS.bit.TBPHS = tbphs9;

    // 마스터 파형에 시간 동기화
    EPwm1Regs.TBCTL.bit.SWFSYNC = 1;

    // 인터럽트 처리 완료
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

}

/*
// 스위치 인터럽트
__interrupt void xint1ISR(void)
{
    Uint16 tbphs9;

    // 스위치 입력에 따라 0 <-> 45deg 토글
    epwm9Phase45 ^= 1U;
    tbphs9 = (epwm9Phase45) ? TBPHS_DELAY_45 : 0U;

    // TBPHS 반영
    EPwm9Regs.TBPHS.bit.TBPHS = tbphs9;

    // 바로 다음 주기부터 확실히 반영시키고 싶으면 SWFSYNC 한 번
    EPwm1Regs.TBCTL.bit.SWFSYNC = 1;

    // XINT1 플래그 클리어(중요)
    XintRegs.XINT1CR.bit.ENABLE = 0;  // (선택) 글리치 방지용 잠깐 disable
    XintRegs.XINT1CR.bit.ENABLE = 1;

    // PIE ACK (Group1)
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
 */

// main
void main(void)
{
    // ---- System init ----
    InitSysCtrl();
    DINT;

    // GPIO 기본 초기화(필요한 경우)
    InitGpio();

    // ---- PIE init ----
    InitPieCtrl();
    IER = 0x0000;
    IFR = 0x0000;
    InitPieVectTable();

    // ---- ISR vector mapping (반드시 EALLOW/EDIS) ----
    EALLOW;
    PieVectTable.TIMER0_INT = &cpuTimer0ISR;   // CPU Timer0 ISR 연결
    // PieVectTable.XINT1_INT = &xint1ISR;     // <- XINT1은 InitSwitchXint1()에서 연결하므로 중복 금지
    EDIS;

    // ---- ePWM time-base stop for synchronous start ----
    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0;      // ePWM TBCLK 정지
    EDIS;

    // ---- ePWM init ----
    InitEPwm1();
    InitEPwm2();
    InitEPwm3();
    InitEPwm4();
    InitEPwm5();
    InitEPwm6();
    InitEPwm7();
    InitEPwm8();
    InitEPwm9();
    InitEPwm10();
    InitEPwm11();
    InitEPwm12();

    // ---- ePWM time-base start together ----
    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;      // ePWM TBCLK 동시 시작
    EDIS;

    // ---- External switch interrupt (XINT1) init ----
    // 1) GPIO62 입력/풀업/퀄리파이
    // 2) InputXbar INPUT1SELECT = 62
    // 3) XINT1 enable + PIE(Group1 INT4) enable + IER(M_INT1)
    // 4) PieVectTable.XINT1_INT = &xint1ISR
    EPWM9SW1Int();

    // ---- CPU Timer0 init: 1s interrupt ----
    InitCpuTimers();

    // CPU SYSCLK = 200MHz
    ConfigCpuTimer(&CpuTimer0, 200, 1000000);

    // Timer0 동작/인터럽트 조건 ON
    CpuTimer0Regs.TCR.bit.TSS = 1;  // stop
    CpuTimer0Regs.TCR.bit.TRB = 1;  // reload
    CpuTimer0Regs.TCR.bit.TIF = 1;  // clear flag
    CpuTimer0Regs.TCR.bit.TIE = 1;  // enable interrupt
    CpuTimer0Regs.TCR.bit.TSS = 0;  // start

    // PIE/CPU enable (Timer0 = Group1 INT7)
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1;
    IER |= M_INT1;                  // Group1 전체 enable (XINT1도 같은 그룹)

    // ---- Global interrupt enable ----
    EINT;
    ERTM;

    // ---- Loop ----
    while(1)
    {
        // 필요 시 idle
        asm(" NOP");
    }
}
